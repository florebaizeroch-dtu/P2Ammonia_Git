# %%

# import glob
# import os
# import time
# import copy

# basic libraries
import numpy as np
# from numpy import newaxis as na
import pandas as pd
import openmdao.api as om
# import yaml

# import xarray as xr
from docplex.mp.model import Model
from hydesign.ems.ems import expand_to_lifetime, split_in_batch

class ems_P2Ammonia(om.ExplicitComponent):
    """Energy management optimization model for HPP with P2Ammonia
    The energy management system optimization model consists in maximizing the revenue generated by the plant over a period of time,
    including a possible penalty for not meeting the requirement of energy generation during peak hours over the period. It also assigns
    a cost for rapid fluctuations of the battery in order to slow down its degradation.
    The EMS type is a CPLEX optimization.

    Parameters
    ----------
    -- HPP design --
    wind_t : WPP power time series [MW]
    solar_t : PVP power time series [MW]
    price_t : Electricity price time series 
    b_P : Battery power capacity [MW]
    b_E : Battery energy storage capacity [MW]
    G_MW : Grid capacity [MW]
    battery_depth_of_discharge : battery depth of discharge
    battery_charge_efficiency : Wake affected power curve
    peak_hr_quantile : Quantile of price time series to define peak price hours (above this quantile)
    cost_of_battery_P_fluct_in_peak_price_ratio : cost of battery power fluctuations computed as a peak price ratio
    n_full_power_hours_expected_per_day_at_peak_price : Penalty occurs if number of full power hours expected per day at peak price are not reached
    
    -- H2 production --
    price_H2: Price of Hydrogen
    ptg_MW: Electrolyzer power capacity
    ptg_deg: Electrolyzer rate of degradation annually
    hhv_H2 : High heat value of hydrogen
    lhv_H2 : Low heat value of hydrogen 
    m_H2_demand_t: Hydrogen demand times series
    H2_storage_eff: Compressor efficiency for hydrogen storage
    HSS_kg: Hydrogen storage system capacity
    penalty_factor_H2: Penalty for not meeting hydrogen demand in an hour

    -- N2 production --
    P_elec_N2: Power consumption for ASU per kg of N2 extracted

    -- NH3 production -- 
    price_NH3: Price of Ammonia
    hhv_NH3 : High heat value of ammonia
    lhv_NH3 : Low heat value of ammonia
    NH3_tpd: Haber-Bosch system capacity in tons per day
    P_elec_NH3_kg: Power consumption for Haber-Bosch process per kg of NH3 produced
    m_NH3_demand_t: Ammonia demand times series
    NH3SS_kg: Ammonia storage system capacity
    NH3_storage_eff: Efficiency of the Ammonia storage
    penalty_factor_NH3: Penalty for not meeting ammonia demand in an hour

    Returns
    -------
    wind_t_ext : WPP power time series
    solar_t_ext : PVP power time series
    price_t_ext : Electricity price time series
    hpp_t : HPP power time series
    hpp_curt_t : HPP curtailed power time series
    b_t : Battery charge/discharge power time series
    b_E_SOC_t : Battery energy SOC time series
    penalty_t : Penalty for not reaching expected energy productin at peak hours
    P_ptg_t: Electrolyzer power consumption time series
    P_HB_t: Haber-Bosch power consumption time series
    P_ASU_t: ASU power consumption time series
    m_H2_t: Hydrogen production time series
    m_NH3_t: Ammonia production time series
    m_H2_demand_t_ext: Hydrogen demand times series
    m_NH3_demand_t_ext: Ammonia demand time series
    m_H2_demand_t: Hydrogen offtake times series
    m_NH3_demand_t: Ammonia offtake time series
    LoS_H2_t: H2 storage level time series
    LoS_NH3_t: NH3 storage level time series
    Q_t : heat production time series
    """

    def __init__(
        self, 
        N_time, 
        eff_curve,
        life_y = 25,
        intervals_per_hour = 1,
        ems_type='cplex',
        load_min_penalty_factor=1e6,
        electrolyzer_eff_curve_type='production',
        ):

        super().__init__()
        self.N_time = int(N_time)
        self.eff_curve = eff_curve
        self.ems_type = ems_type
        self.life_y = life_y
        self.life_h = 365 * 24 * life_y
        self.life_intervals = self.life_h * intervals_per_hour
        self.load_min_penalty_factor = load_min_penalty_factor
        self.electrolyzer_eff_curve_type = electrolyzer_eff_curve_type

    def setup(self):
        self.add_input(
            'wind_t',
            desc="WPP power time series",
            units='MW',
            shape=[self.N_time])
        self.add_input(
            'solar_t',
            desc="PVP power time series",
            units='MW',
            shape=[self.N_time])
        self.add_input(
            'price_t',
            desc="Electricity price time series",
            shape=[self.N_time])
        self.add_input(
            'b_P',
            desc="Battery power capacity",
            units='MW')
        self.add_input(
            'b_E',
            desc="Battery energy storage capacity")
        self.add_input(
            'G_MW',
            desc="Grid capacity",
            units='MW')
        self.add_input(
            'battery_depth_of_discharge',
            desc="battery depth of discharge",
            units='MW')
        self.add_input(
            'battery_charge_efficiency',
            desc="battery charge efficiency")
        self.add_input(
            'peak_hr_quantile',
            desc="Quantile of price tim sereis to define peak price hours (above this quantile).\n"+
                 "Only used for peak production penalty and for cost of battery degradation.")
        self.add_input(
            'cost_of_battery_P_fluct_in_peak_price_ratio',
            desc="cost of battery power fluctuations computed as a peak price ratio.")
        self.add_input(
            'n_full_power_hours_expected_per_day_at_peak_price',
            desc="Penalty occurs if nunmber of full power hours expected per day at peak price are not reached.")
        self.add_input(
            'price_H2',
            desc="H2 price")
        self.add_input(
            'price_NH3',
            desc="NH3 price")
        self.add_input(
            'water_treatment_cost',
            desc="Cost for water treatment")
        self.add_input(
            'water_cost',
            desc="Cost for water ")
        self.add_input(
            'water_consumption',
            desc="consumption of water per kg of H2 produced")
        self.add_input(
            'ptg_MW',
            desc="Electrolyzer power capacity.",
            units='MW')
        self.add_input(
            'NH3_tpd',
            desc="Haber-Bosch unit capacity.")
        self.add_input(
            'P_elec_NH3_kg',
            desc="Power consumption of HB process.")
        self.add_input(
            'P_elec_N2_kg',
            desc="Power consumption of ASU.")
        self.add_input(
            'H2_storage_eff',
            desc="Compressor efficiency for hydrogen storage.")
        self.add_input(
            'NH3_storage_eff',
            desc="Efficiency for ammonia storage.")
        self.add_input(
            'ptg_deg',
            desc="Electrolyzer rate of degradation annually.")
        self.add_input(
            'hhv_H2',
            desc="High heat value of hydrogen.")
        self.add_input(
            'lhv_H2',
            desc="Low heat value of hydrogen.")
        self.add_input(
            'hhv_NH3',
            desc="High heat value of ammonia.")
        self.add_input(
            'lhv_NH3',
            desc="Low heat value of ammonia.")
        self.add_input(
            'm_H2_demand_t',
            desc="Hydrogen demand times series.",
            units='kg',
            shape=[self.N_time])
        self.add_input(
            'm_NH3_demand_t',
            desc="Ammonia demand times series.",
            units='kg',
            shape=[self.N_time])
        self.add_input(
            'HSS_kg',
            desc="Hydrogen storage capacity",
            units='kg')
        self.add_input(
            'NH3SS_kg',
            desc="Ammonia storage capacity",
            units='kg')
        self.add_input(
            'penalty_factor_H2',
            desc="Penalty for not meeting hydrogen demand in an hour")
        self.add_input(
            'penalty_factor_NH3',
            desc="Penalty for not meeting ammonia demand in an hour")
        self.add_input(
            'min_power_standby',
            desc="Minimum percentage of rated electrolyzer power required to operate in standby mode")
        
        # ----------------------------------------------------------------------------------------------------------
        self.add_output(
            'wind_t_ext',
            desc="WPP power time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'solar_t_ext',
            desc="PVP power time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'price_t_ext',
            desc="Electricity price time series",
            shape=[self.life_h])
        self.add_output(
            'hpp_t',
            desc="HPP power time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'hpp_curt_t',
            desc="HPP curtailed power time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'b_t',
            desc="Battery charge/discharge power time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'b_E_SOC_t',
            desc="Battery energy SOC time series",
            shape=[self.life_h + 1])
        self.add_output(
            'penalty_t',
            desc="penalty for not reaching expected energy production at peak hours",
            shape=[self.life_h])        
        self.add_output(
            'P_ptg_t',
            desc="Electrolyzer power consumption time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'P_HB_t',
            desc="Haber-Bosch power consumption time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'P_ASU_t',
            desc="ASU power consumption time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'P_ptg_SB_t',
            desc="Electrolyzer standby mode power consumption time series",
            units='MW',
            shape=[self.life_h])
        self.add_output(
            'm_H2_t',
            desc="Hydrogen production time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'm_NH3_t',
            desc="Ammonia production time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'm_H2_offtake_t',
            desc="Hydrogen offtake time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'm_H2_to_NH3_t',
            desc="Hydrogen to Ammonia time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'm_NH3_offtake_t',
            desc="Ammonia offtake time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'LoS_H2_t',
            desc="H2 storage level time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'LoS_NH3_t',
            desc="NH3 storage level time series",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'total_curtailment',
            desc="total curtailment in the lifetime",
            units='GW*h')
        self.add_output(
            'm_H2_demand_t_ext',
            desc="Hydrogen demand times series.",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'm_NH3_demand_t_ext',
            desc="Ammonia demand times series.",
            units='kg',
            shape=[self.life_h])
        self.add_output(
            'Q_t',
            desc="Heat production times series.",
            units='MW',
            shape=[self.life_h])
        
        
        
    # def setup_partials(self):
    #    self.declare_partials('*', '*',  method='fd')

    def compute(self, inputs, outputs):
        
        wind_t = inputs['wind_t']
        solar_t = inputs['solar_t']
        price_t = inputs['price_t']
        m_H2_demand_t = inputs['m_H2_demand_t']
        m_NH3_demand_t = inputs['m_NH3_demand_t']
        b_P = inputs['b_P']
        b_E = inputs['b_E']
        G_MW = inputs['G_MW']
        NH3_tpd = inputs['NH3_tpd']
        HSS_kg = inputs['HSS_kg']
        NH3SS_kg = inputs['NH3SS_kg']

        if self.ems_type == 'cplex':
            ems_WSB = ems_cplex_P2Ammonia
        else:
            raise Warning("This class should only be used for ems_cplex_P2Ammonia")

        
        # Avoid running an expensive optimization based ems if there is no battery
        # if ( b_P <= 1e-2 ) or (b_E == 0):
          #  ems_WSB = ems_rule_based
    
        battery_depth_of_discharge = inputs['battery_depth_of_discharge']
        battery_charge_efficiency = inputs['battery_charge_efficiency']
        peak_hr_quantile = inputs['peak_hr_quantile'][0]
        cost_of_battery_P_fluct_in_peak_price_ratio = inputs['cost_of_battery_P_fluct_in_peak_price_ratio'][0]
        n_full_power_hours_expected_per_day_at_peak_price = inputs[
            'n_full_power_hours_expected_per_day_at_peak_price'][0]
        price_H2 = inputs['price_H2'][0]
        price_NH3 = inputs['price_NH3'][0]
        water_cost = inputs['water_cost'][0]
        water_treatment_cost = inputs['water_treatment_cost'][0]
        water_consumption = inputs['water_consumption'][0]
        ptg_MW = inputs['ptg_MW'][0]
        ptg_deg = inputs['ptg_deg'][0]
        P_elec_NH3_kg = inputs['P_elec_NH3_kg'][0]
        P_elec_N2_kg = inputs['P_elec_N2_kg'][0]
        H2_storage_eff = inputs['H2_storage_eff'][0]
        NH3_storage_eff = inputs['NH3_storage_eff'][0]
        hhv_H2 = inputs['hhv_H2'][0]
        lhv_H2 = inputs['lhv_H2'][0]
        hhv_NH3 = inputs['hhv_NH3'][0]
        lhv_NH3 = inputs['lhv_NH3'][0]
        penalty_factor_H2 = inputs['penalty_factor_H2'][0]
        penalty_factor_NH3 = inputs['penalty_factor_NH3'][0]
        min_power_standby = inputs['min_power_standby'][0]

        # Build a sintetic time to avoid problems with time sereis 
        # indexing in ems
        WSPr_df = pd.DataFrame(
            index=pd.date_range(
                start='01-01-1991 00:00',
                periods=len(wind_t),
                freq='1h'))

        WSPr_df['wind_t'] = wind_t
        WSPr_df['solar_t'] = solar_t
        WSPr_df['price_t'] = price_t
        WSPr_df['m_H2_demand_t'] = m_H2_demand_t  
        WSPr_df['m_NH3_demand_t'] = m_NH3_demand_t  
        WSPr_df['E_batt_MWh_t'] = b_E[0]
        WSPr_df['H2_storage_t'] = HSS_kg[0]
        WSPr_df['NH3_storage_t'] = NH3SS_kg[0]
        WSPr_df['NH3_tpd_t'] = NH3_tpd[0]

        #print(WSPr_df.head())

        P_HPP_ts, P_curtailment_ts, P_charge_discharge_ts, P_ptg_ts, P_ptg_SB_ts, E_SOC_ts, m_H2_ts, m_H2_offtake_ts, m_H2_to_NH3_ts, LoS_H2_ts, penalty_ts, P_HB_ts, P_ASU_ts, m_NH3_ts, LoS_NH3_ts, m_NH3_offtake_ts, Q_ts = ems_WSB(
            wind_ts = WSPr_df.wind_t,
            solar_ts = WSPr_df.solar_t,
            price_ts = WSPr_df.price_t,
            P_batt_MW = b_P[0],
            E_batt_MWh_t = WSPr_df.E_batt_MWh_t,
            hpp_grid_connection = G_MW[0],
            battery_depth_of_discharge = battery_depth_of_discharge[0],
            charge_efficiency = battery_charge_efficiency[0],
            price_H2 = price_H2,
            price_NH3 = price_NH3,
            water_treatment_cost= water_treatment_cost,
            water_cost= water_cost,
            water_consumption= water_consumption,
            ptg_MW = ptg_MW,
            NH3_tpd_ts = WSPr_df.NH3_tpd_t,
            HSS_kg = HSS_kg,
            NH3SS_kg = NH3SS_kg,
            H2_storage_eff = H2_storage_eff,
            NH3_storage_eff = NH3_storage_eff,
            ptg_deg = ptg_deg,
            hhv_H2 = hhv_H2,
            lhv_H2 = lhv_H2,
            hhv_NH3 = hhv_NH3,
            lhv_NH3 = lhv_NH3,
            m_H2_demand_ts = WSPr_df.m_H2_demand_t,
            m_NH3_demand_ts = WSPr_df.m_NH3_demand_t,
            H2_storage_t = WSPr_df.H2_storage_t,
            NH3_storage_t = WSPr_df.NH3_storage_t,
            penalty_factor_H2 =penalty_factor_H2,
            penalty_factor_NH3 =penalty_factor_NH3,
            P_elec_N2_kg = P_elec_N2_kg,
            P_elec_NH3_kg = P_elec_NH3_kg,
            eff_curve=self.eff_curve,
            min_power_standby = min_power_standby,
            load_min_penalty_factor = self.load_min_penalty_factor,
            peak_hr_quantile = peak_hr_quantile,
            cost_of_battery_P_fluct_in_peak_price_ratio = cost_of_battery_P_fluct_in_peak_price_ratio,
            n_full_power_hours_expected_per_day_at_peak_price = n_full_power_hours_expected_per_day_at_peak_price,
            electrolyzer_eff_curve_type = self.electrolyzer_eff_curve_type
        )

        # Extend (by repeating them and stacking) all variable to full lifetime 
        outputs['wind_t_ext'] = expand_to_lifetime(
            wind_t, life = self.life_intervals)
        outputs['solar_t_ext'] = expand_to_lifetime(
            solar_t, life = self.life_intervals)
        outputs['price_t_ext'] = expand_to_lifetime(
            price_t, life = self.life_intervals)
        outputs['hpp_t'] = expand_to_lifetime(
            P_HPP_ts, life = self.life_intervals)
        outputs['hpp_curt_t'] = expand_to_lifetime(
            P_curtailment_ts, life = self.life_intervals)
        outputs['b_t'] = expand_to_lifetime(
            P_charge_discharge_ts, life = self.life_intervals)
        outputs['b_E_SOC_t'] = expand_to_lifetime(
            E_SOC_ts[:-1], life = self.life_intervals + 1)
        outputs['penalty_t'] = expand_to_lifetime(
            penalty_ts, life = self.life_intervals)
        outputs['P_ptg_t'] = expand_to_lifetime(
            P_ptg_ts, life = self.life_intervals)
        outputs['P_ptg_SB_t'] = expand_to_lifetime(
            P_ptg_SB_ts, life = self.life_intervals)
        outputs['m_H2_t'] = expand_to_lifetime(
            m_H2_ts, life = self.life_intervals)
        outputs['m_H2_offtake_t'] = expand_to_lifetime(
            m_H2_offtake_ts, life = self.life_intervals)
        outputs['LoS_H2_t'] = expand_to_lifetime(
            LoS_H2_ts, life = self.life_intervals)
        outputs['total_curtailment'] = outputs['hpp_curt_t'].sum()
        outputs['m_H2_demand_t_ext'] = expand_to_lifetime(
            m_H2_demand_t, life = self.life_intervals)
        outputs['P_HB_t'] = expand_to_lifetime(
            P_HB_ts, life = self.life_intervals)
        outputs['P_ASU_t'] = expand_to_lifetime(
            P_ASU_ts, life = self.life_intervals)
        outputs['m_NH3_t'] = expand_to_lifetime(
            m_NH3_ts, life = self.life_intervals)
        outputs['LoS_NH3_t'] = expand_to_lifetime(
            LoS_NH3_ts, life = self.life_intervals)
        outputs['m_NH3_demand_t_ext'] = expand_to_lifetime(
            m_NH3_demand_t, life = self.life_intervals)
        outputs['m_NH3_offtake_t'] = expand_to_lifetime(
            m_NH3_offtake_ts, life = self.life_intervals)
        outputs['Q_t'] = expand_to_lifetime(
            Q_ts, life = self.life_intervals)
        outputs['m_H2_to_NH3_t']= expand_to_lifetime(
            m_H2_to_NH3_ts, life = self.life_intervals)
       
def ems_cplex_P2Ammonia(
    wind_ts,
    solar_ts,
    price_ts,
    P_batt_MW,
    E_batt_MWh_t,
    hpp_grid_connection,
    battery_depth_of_discharge,
    charge_efficiency,
    price_H2,
    price_NH3,
    water_treatment_cost,
    water_cost,
    water_consumption,
    ptg_MW,
    NH3_tpd_ts,
    HSS_kg,
    NH3SS_kg,
    H2_storage_eff,
    NH3_storage_eff,
    ptg_deg,
    hhv_H2,
    lhv_H2,
    hhv_NH3,
    lhv_NH3,
    m_H2_demand_ts,
    m_NH3_demand_ts,
    H2_storage_t,
    NH3_storage_t,
    penalty_factor_H2,
    penalty_factor_NH3,
    eff_curve,
    P_elec_NH3_kg,
    P_elec_N2_kg,
    min_power_standby,
    load_min_penalty_factor = 1e6,
    peak_hr_quantile = 0.9,
    cost_of_battery_P_fluct_in_peak_price_ratio = 0.5, #[0, 0.8]. For higher values might cause errors
    n_full_power_hours_expected_per_day_at_peak_price = 3,  
    batch_size = 2*24, 
    electrolyzer_eff_curve_type = 'production',
    ):
    
    # split in batches, ussually a week
    batches_all = split_in_batch(list(range(len(wind_ts))), batch_size)
    # Make sure the last batch is not smaller than the others
    # instead append it to the previous last one
    # batches = batches_all[:-1]
    # batches[-1] = batches_all[-2]+batches_all[-1]
    batches = batches_all
    
    # allocate vars
    P_HPP_ts = np.zeros(len(wind_ts))
    P_curtailment_ts = np.zeros(len(wind_ts))
    P_charge_discharge_ts = np.zeros(len(wind_ts))
    P_ptg_ts = np.zeros(len(wind_ts))
    P_ptg_SB_ts = np.zeros(len(wind_ts))
    m_H2_ts = np.zeros(len(wind_ts))
    m_H2_offtake_ts = np.zeros(len(wind_ts))
    LoS_H2_ts = np.zeros(len(wind_ts))
    E_SOC_ts = np.zeros(len(wind_ts)+1)
    penalty_ts = np.zeros(len(wind_ts))
    P_HB_ts = np.zeros(len(wind_ts))
    P_ASU_ts = np.zeros(len(wind_ts))
    m_NH3_ts = np.zeros(len(wind_ts))
    m_H2_to_NH3_ts = np.zeros(len(wind_ts))
    LoS_NH3_ts = np.zeros(len(wind_ts))
    m_NH3_offtake_ts = np.zeros(len(wind_ts))
    Q_ts = np.zeros(len(wind_ts))

    for ib, batch in enumerate(batches):
        wind_ts_sel = wind_ts.iloc[batch]
        solar_ts_sel = solar_ts.iloc[batch]
        price_ts_sel = price_ts.iloc[batch]
        E_batt_MWh_t_sel = E_batt_MWh_t.iloc[batch] 
        m_H2_demand_ts_sel = m_H2_demand_ts.iloc[batch]
        m_NH3_demand_ts_sel = m_NH3_demand_ts.iloc[batch]
        H2_storage_t_sel = H2_storage_t.iloc[batch]
        NH3_storage_t_sel = NH3_storage_t.iloc[batch]
        NH3_tpd_t_sel = NH3_tpd_ts.iloc[batch]

            
        #print(f'batch {ib+1} out of {len(batches)}')
        P_HPP_ts_batch, P_curtailment_ts_batch, P_charge_discharge_ts_batch, P_ptg_ts_batch, P_ptg_SB_ts_batch,\
        E_SOC_ts_batch, m_H2_ts_batch, m_H2_offtake_ts_batch, m_H2_to_NH3_ts_batch, LoS_H2_ts_batch, penalty_batch, P_HB_ts_batch, P_ASU_ts_batch, m_NH3_ts_batch, LoS_NH3_ts_batch, m_NH3_offtake_ts_batch, Q_ts_batch = ems_cplex_parts_P2Ammonia(
            wind_ts = wind_ts_sel,
            solar_ts = solar_ts_sel,
            price_ts = price_ts_sel,
            P_batt_MW = P_batt_MW,
            E_batt_MWh_t = E_batt_MWh_t_sel,
            hpp_grid_connection = hpp_grid_connection,
            battery_depth_of_discharge = battery_depth_of_discharge,
            charge_efficiency = charge_efficiency,
            price_H2=price_H2,
            price_NH3 = price_NH3,
            water_treatment_cost = water_treatment_cost,
            water_cost = water_cost,
            water_consumption = water_consumption,
            ptg_MW=ptg_MW,
            NH3_tpd_ts = NH3_tpd_t_sel,
            HSS_kg=HSS_kg,
            NH3SS_kg = NH3SS_kg,
            H2_storage_eff=H2_storage_eff,
            NH3_storage_eff = NH3_storage_eff,
            ptg_deg=ptg_deg,
            hhv_H2=hhv_H2,
            lhv_H2 = lhv_H2,
            hhv_NH3 = hhv_NH3,
            lhv_NH3 = lhv_NH3,
            m_H2_demand_ts = m_H2_demand_ts_sel,
            m_NH3_demand_ts = m_NH3_demand_ts_sel,
            H2_storage_t = H2_storage_t_sel,
            NH3_storage_t = NH3_storage_t_sel,
            penalty_factor_H2 = penalty_factor_H2,
            penalty_factor_NH3 = penalty_factor_NH3,
            eff_curve = eff_curve,
            min_power_standby = min_power_standby,
            P_elec_N2_kg = P_elec_N2_kg,
            P_elec_NH3_kg = P_elec_NH3_kg,
            load_min_penalty_factor = load_min_penalty_factor,
            peak_hr_quantile = peak_hr_quantile,
            cost_of_battery_P_fluct_in_peak_price_ratio = cost_of_battery_P_fluct_in_peak_price_ratio,
            n_full_power_hours_expected_per_day_at_peak_price = n_full_power_hours_expected_per_day_at_peak_price,      
            electrolyzer_eff_curve_type = electrolyzer_eff_curve_type)
        
        # print()
        # print()
        # print()
        # print(ib, len(batch))
        # print()
        # print('len(wind_ts_sel)',len(wind_ts_sel))
        # print('len(P_HPP_ts_batch)',len(P_HPP_ts_batch))
        # print('len(P_curtailment_ts_batch)',len(P_curtailment_ts_batch))
        # print('len(P_charge_discharge_ts_batch)',len(P_charge_discharge_ts_batch))
        # print('len(E_SOC_ts_batch)',len(E_SOC_ts_batch))
        # print('len(penalty_batch)',len(penalty_batch))
        
        P_HPP_ts[batch] = P_HPP_ts_batch
        P_curtailment_ts[batch] = P_curtailment_ts_batch
        P_charge_discharge_ts[batch] = P_charge_discharge_ts_batch
        E_SOC_ts[batch] = E_SOC_ts_batch[:-1]
        penalty_ts[batch] = penalty_batch
        P_ptg_ts[batch] = P_ptg_ts_batch
        P_ptg_SB_ts[batch] = P_ptg_SB_ts_batch
        m_H2_ts[batch] = m_H2_ts_batch
        m_H2_offtake_ts[batch] = m_H2_offtake_ts_batch
        m_H2_to_NH3_ts[batch] = m_H2_to_NH3_ts_batch
        LoS_H2_ts[batch] = LoS_H2_ts_batch
        P_HB_ts[batch] = P_HB_ts_batch
        P_ASU_ts[batch] = P_ASU_ts_batch
        m_NH3_ts[batch] = m_NH3_ts_batch
        LoS_NH3_ts[batch] = LoS_NH3_ts_batch
        m_NH3_offtake_ts[batch] = m_NH3_offtake_ts_batch
        Q_ts[batch] = Q_ts_batch

    E_SOC_ts[-1] = E_SOC_ts[0]
    LoS_H2_ts[-1] = LoS_H2_ts[0]
    LoS_NH3_ts[-1] = LoS_NH3_ts[0]

    
    return P_HPP_ts, P_curtailment_ts, P_charge_discharge_ts, P_ptg_ts, P_ptg_SB_ts, E_SOC_ts, m_H2_ts, m_H2_offtake_ts, m_H2_to_NH3_ts, LoS_H2_ts, penalty_ts, P_HB_ts, P_ASU_ts, m_NH3_ts, LoS_NH3_ts, m_NH3_offtake_ts, Q_ts


def ems_cplex_parts_P2Ammonia(
    wind_ts,
    solar_ts,
    price_ts,
    P_batt_MW,
    E_batt_MWh_t,
    hpp_grid_connection,
    battery_depth_of_discharge,
    charge_efficiency,
    price_H2,
    price_NH3,
    water_treatment_cost,
    water_cost,
    water_consumption,
    ptg_MW,
    NH3_tpd_ts,
    HSS_kg,
    NH3SS_kg,
    H2_storage_eff,
    NH3_storage_eff,
    ptg_deg,
    hhv_H2,
    lhv_H2,
    hhv_NH3,
    lhv_NH3,
    m_H2_demand_ts,
    m_NH3_demand_ts,
    H2_storage_t,
    NH3_storage_t,
    penalty_factor_H2,
    penalty_factor_NH3,
    eff_curve,
    min_power_standby,
    P_elec_NH3_kg,
    P_elec_N2_kg,
    load_min_penalty_factor = 1e6,
    peak_hr_quantile = 0.9,
    cost_of_battery_P_fluct_in_peak_price_ratio = 0.5, #[0, 0.8]. For higher values might cause errors
    n_full_power_hours_expected_per_day_at_peak_price = 3,
    electrolyzer_eff_curve_type = 'production',    
    ):
    """EMS solver implemented in cplex

    Parameters
    ----------
    wind_ts : WPP power time series
    solar_ts : PVP power time series
    price_ts : price time series
    P_batt_MW : battery power
    E_batt_MWh_t : battery energy capacity time series
    H2_storage_t : hydrogen storgae capacity time series
    hpp_grid_connection : grid connection
    battery_depth_of_discharge : battery depth of discharge
    charge_efficiency : battery charge efficiency
    peak_hr_quantile : quantile of price time series to define peak price hours
    cost_of_battery_P_fluct_in_peak_price_ratio : cost of battery power fluctuations computed as a peak price ratio
    n_full_power_hours_expected_per_day_at_peak_price : Penalty occurs if number of full power hours expected per day at peak price are not reached
    price_H2: Price of Hydrogen
    price_NH3: Price of Ammonia
    ptg_MW: Electrolyzer power capacity
    HSS_kg: Hydrogen storage capacity
    NH3SS_kg: Ammonia storage capacity
    H2_storage_eff: Compressor efficiency for hydrogen storage
    NH3_storage_eff: Efficiency for Ammonia storage
    ptg_deg: Electrolyzer rate of degradation annually
    hhv_H2: High heat value of H2
    lhv_H2: Low heat value of H2
    hhv_NH3: High heat value of NH3
    lhv_NH3: Low heat value of NH3
    m_H2_demand_ts: Hydrogen demand times series 
    m_NH3_demand_ts: Ammonia demand time series
    penalty_factor_H2: Penalty on not meeting hydrogen demand in an hour
    penalty_factor_NH3: Penalty on not meeting ammonia demand in an hour

    Returns
    -------
    P_HPP_ts: HPP power time series
    P_curtailment_ts: HPP curtailed power time series
    P_charge_discharge_ts: Battery charge/discharge power time series 
    E_SOC_ts: Battery energy SOC time series 
    penalty_ts: penalty time series for not reaching expected energy production at peak hours
    P_ptg_ts: Electrolyzer power consumption time series
    P_ptg_SB_ts: Electrolyzer standby mode power consumption time series
    m_H2_ts: Hydrogen production time series
    m_H2_offtake_ts: Hydrogen offtake time series
    LoS_H2_ts: Level of Hydrogen storage time series
    P_HB_ts: Haber_Bosch power consumption 
    P_ASU_ts: ASU power consumption
    m_NH3_ts: Ammonia production time series
    LoS_NH3_ts: Ammonia level of storage time series
    m_NH3_demand_ts: Ammonia demand time series
    m_NH3_offtake_ts: Ammonia offtake time series
    """
    
    # Penalties 
    N_t = len(price_ts.index) 
    N_days = N_t/24
    e_peak_day_expected = n_full_power_hours_expected_per_day_at_peak_price*hpp_grid_connection 
    e_peak_period_expected = e_peak_day_expected*N_days
    price_peak = np.quantile(price_ts.values, peak_hr_quantile)
    peak_hours_index = np.where(price_ts>=price_peak)[0]
    
    price_ts_to_max = price_peak - price_ts
    price_ts_to_max.loc[price_ts_to_max<0] = 0
    price_ts_to_max.iloc[:-1] = 0.5*price_ts_to_max.iloc[:-1].values + 0.5*price_ts_to_max.iloc[1:].values
        
    mdl = Model(name='EMS')
    mdl.context.cplex_parameters.threads = 1
    # CPLEX parameter pg 87 Emphasize feasibility over optimality
    mdl.context.cplex_parameters.emphasis.mip = 1    
    
    time = price_ts.index
    # time set with an additional time slot for the last soc
    SOCtime = time.append(pd.Index([time[-1] + pd.Timedelta('1hour')]))

    # Variables definition
    P_HPP_t = mdl.continuous_var_dict(time, lb=0, ub=hpp_grid_connection, name='HPP power output')
    P_curtailment_t = mdl.continuous_var_dict(time, lb=0, name='Curtailment')

    # Power charge/discharge from battery
    P_charge_discharge = mdl.continuous_var_dict(time, lb=-P_batt_MW/charge_efficiency, ub=P_batt_MW*charge_efficiency, name='Battery power')
    # Battery energy level, energy stored
    E_SOC_t = mdl.continuous_var_dict(SOCtime, lb=0, name='Energy level')
    
    # Hydrogen storgae level
    LoS_H2_t = mdl.continuous_var_dict(SOCtime, lb=0, name='Hydrogen storage level')
    
    # Power to gas plant power consumption, produced hydrogen, electrolyzer efficiency
    P_ptg_t = mdl.continuous_var_dict(time, lb=min_power_standby * ptg_MW, ub=ptg_MW, name = "Power to gas plant consumption")
    m_H2_t = mdl.continuous_var_dict(time, lb = 0, name = 'Produced hydrogen')
    m_H2_offtake_t = mdl.continuous_var_dict(time, lb = 0, name = 'Hydrogen offtake')
    
    #Ammonia related variables
    m_H2_to_NH3_t = mdl.continuous_var_dict(time, lb=0, name ='Hydrogen consumption of Haber-Bosch process')
    P_HB_t = mdl.continuous_var_dict(time, lb=0, name ='Power consumption of Haber-Bosch process')
    P_ASU_t = mdl.continuous_var_dict(time, lb=0, name ='Power consumption of ASU process')
    m_NH3_t = mdl.continuous_var_dict(time, lb=0, name ='Ammonia production')
    m_N2_t = mdl.continuous_var_dict(time, lb=0, name ='Nitrogen production')
    m_NH3_offtake_t = mdl.continuous_var_dict(time, lb=0, name ='Ammonia offtake')
    LoS_NH3_t = mdl.continuous_var_dict(SOCtime, lb=0, name='Ammonia storage level')
    Q_t = mdl.continuous_var_dict(time,lb=0, name = 'Heat production')
    #penalty = mdl.continuous_var(name='penalty', lb=-1e12)
    #e_penalty = mdl.continuous_var(name='e_penalty', lb=-1e12)
    
    # Piecewise function for "absolute value" function
    fabs = mdl.piecewise(-1, [(0,0)], 1)
       
    #Constraints
    #mdl.add_constraint(e_penalty == ( e_peak_period_expected - mdl.sum(P_HPP_t[time[i]] for i in peak_hours_index)))
    # Piecewise function for "only positive" function
    f1 = mdl.piecewise(0, [(0,0)], 1)
    
#    mdl.add_constraint( penalty == price_peak*f1(e_penalty) + \
#                      mdl.sum(penalty_factor_H2*(m_H2_demand_ts[t] - m_H2_offtake_t[t]) + penalty_factor_NH3*(m_NH3_demand_ts[t] - m_NH3_offtake_t[t]) for t in time) )
    #mdl.add_constraint( penalty == price_peak*f1(e_penalty))

    # Intitial and end SOC
    mdl.add_constraint( E_SOC_t[SOCtime[0]] == 0.5 * E_batt_MWh_t[time[0]] )
    # SOC at the end of the year has to be equal to SOC at the beginning of the year
    mdl.add_constraint( E_SOC_t[SOCtime[-1]] == 0.5 * E_batt_MWh_t[time[0]] )
    
    # Intitial and end LoS_H2
    mdl.add_constraint( LoS_H2_t[SOCtime[0]] == 0 )
    mdl.add_constraint( LoS_H2_t[SOCtime[-1]] == 0 )
    
    # Intitial and end LoS_NH3
    mdl.add_constraint( LoS_NH3_t[SOCtime[0]] == 0 )
    mdl.add_constraint( LoS_NH3_t[SOCtime[-1]] == 0 ) 

    # piecewise linear representation of battery charge vs dischrage effciency 
    f2 = mdl.piecewise(charge_efficiency,[(0,0)],1/charge_efficiency)
    
    # piecewise linear representation of H2 storage vs offtake effciency 
    f3 = mdl.piecewise(1/H2_storage_eff,[(0,0)],H2_storage_eff)
    
    if ptg_MW == 0:
        H2_prod = lambda x: 0
    else :
        # Caclulating electrolyzer efficiency as a function of load (piecewise linear approximation)
        if electrolyzer_eff_curve_type == 'production':
            H2_curve_list = [(load * ptg_MW, H2 * ptg_MW) for load, H2 in eff_curve]
        elif electrolyzer_eff_curve_type == 'efficiency':
            H2_curve_list = [(load * ptg_MW, load * ptg_MW * efficiency / lhv_H2 * 1000) for load, efficiency in eff_curve]
        else :
            raise ValueError(f'electrolyzer_eff_curve_type is: "{electrolyzer_eff_curve_type}". Available options are ["production", "efficiency"]')

        H2_prod = mdl.piecewise(0, H2_curve_list, 0)

    # # Piecewise linear representation of standby mode operation of electrolyzer
    # f5 = mdl.piecewise(0, [(-1,0), (0, min_power_standby * ptg_MW), (1,0)], 0)

    # piecewise linear representation of Ammonia storage vs offtake effciency 
    f6 = mdl.piecewise(1/NH3_storage_eff,[(0,0)],NH3_storage_eff)

    mdl.maximize(
        # revenues and OPEX
        mdl.sum(
            price_ts[t] * P_HPP_t[t] + price_H2  *  m_H2_offtake_t[t]  + price_NH3 * m_NH3_offtake_t[t] \
            - water_consumption * 1e-3 * m_H2_t[t] * (water_cost + water_treatment_cost) \
            - penalty_factor_NH3 * (m_NH3_demand_ts[t] - m_NH3_offtake_t[t]) \
            - penalty_factor_H2 * (m_H2_demand_ts[t] - m_H2_offtake_t[t]) 
            for t in time)

            #- penalty\
        # Add cost for rapid charge-discharge for limiting the battery life use
        #- mdl.sum(
        #   fabs(P_charge_discharge[t + pd.Timedelta('1hour')] - \
        #        P_charge_discharge[t])*cost_of_battery_P_fluct_in_peak_price_ratio*price_ts_to_max[t] for t in time[:-1]
        #        ) 
    ) 
    
    for t in time:
        # Time index for successive time step
        tt = t + pd.Timedelta('1hour')
        # Delta_t of 1 hour
        dt = 1
        
        # Only one variable for battery
        mdl.add_constraint(P_HPP_t[t] == wind_ts[t] + solar_ts[t] - P_curtailment_t[t] + P_charge_discharge[t] - P_ptg_t[t] - P_HB_t[t] - P_ASU_t[t] )
        
        # charge/dischrage equation
        mdl.add_constraint(E_SOC_t[tt] == E_SOC_t[t] - f2(P_charge_discharge[t]) * dt)
        
        # Hydrogen storgae equation
        mdl.add_constraint(LoS_H2_t[tt] == LoS_H2_t[t] + f3(m_H2_t[t] - m_H2_offtake_t[t] - m_H2_to_NH3_t[t]))
        
        # Ammonia storgae equation
        mdl.add_constraint(LoS_NH3_t[tt] == LoS_NH3_t[t] + f6(m_NH3_t[t] - m_NH3_offtake_t[t]))

        # Constraining battery energy level to minimum battery level
        mdl.add_constraint(E_SOC_t[t] >= (1 - battery_depth_of_discharge) * E_batt_MWh_t[t])
        
        # Constraining battery energy level to maximum battery level
        mdl.add_constraint(E_SOC_t[t] <= E_batt_MWh_t[t])

        # Battery charge/discharge within its power rating
        mdl.add_constraint(P_charge_discharge[t] <= P_batt_MW*charge_efficiency)
        mdl.add_constraint(P_charge_discharge[t] >= - P_batt_MW/charge_efficiency)
        
        # Constraining hydrogen offtake as per the demand time series and level of storage
        mdl.add_constraint(LoS_H2_t[t] <= H2_storage_t[t])
        #mdl.add_constraint( m_H2_offtake_t[t] <= m_H2_demand_ts[t])

        # Constraining ammonia offtake as per the demand time series and level of storage
        mdl.add_constraint(LoS_NH3_t[t] <= NH3_storage_t[t])
        mdl.add_constraint( m_NH3_offtake_t[t] <= m_NH3_demand_ts[t])
        mdl.add_constraint( m_NH3_t[t] <= NH3_tpd_ts[t] * 1e3 / (24))
     
     
        # constraint to maintain standby power when electrolyzer is not producing H2
        # Big M method to define the mode of operation of electrolyzer, M = 1e5
        # mdl.add_constraint(P_ptg_t[t] <= 1e5*(1-y_t[t]))
        # mdl.add_constraint(P_ptg_t[t] >= 1e-6*(1-y_t[t]))
        # mdl.add_constraint(P_ptg_SB_t[t] == y_t[t] * min_power_standby * ptg_MW)
        # mdl.add_constraint(penalty_SB[t]>=(1-y_t[t])-P_ptg_t[t]/1e5)

        #mdl.add_constraint( m_H2_offtake_t[t] <= LoS_H2_t[t])
        
        # when the H2 offtake is infinite, there is no storage, then H2_offtake is same as H2_produced and H2 supplied to HB
        if H2_storage_t[t] == 0:
           mdl.add_constraint(m_H2_offtake_t[t] == m_H2_t[t] - m_H2_to_NH3_t[t])
        
        # when the NH3 offtake is infinite, there is no storage, then NH3_offtake is same as NH3_produced
        if NH3_storage_t[t] == 0:
            mdl.add_constraint(m_NH3_offtake_t[t] == m_NH3_t[t])

        # Calculating Hydrogen production with HPC
        mdl.add_constraint(m_H2_t[t] == H2_prod(P_ptg_t[t])) 

        # Calculating Ammonia production
        mdl.add_constraint(m_NH3_t[t] == 5.67 * m_H2_to_NH3_t[t])
        mdl.add_constraint(m_N2_t[t] == 0.82 * m_NH3_t[t])
        
        #Calculating the power consumption related to ammonia production
        mdl.add_constraint(P_HB_t[t] == m_NH3_t[t] * P_elec_NH3_kg / 1e3 )
        mdl.add_constraint(P_ASU_t[t] == m_N2_t[t] * P_elec_N2_kg / 1e3 )
        mdl.add_constraint(Q_t[t] == (46.2/(3.6e6*0.017))*m_NH3_t[t])
    # Solving the problem
    sol = mdl.solve(
        log_output=False)
        #log_output=True)

    
    #print(mdl.export_to_string())
    #sol.display() 

    P_HPP_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(P_HPP_t), orient='index').loc[:,0]
    P_curtailment_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(P_curtailment_t), orient='index').loc[:,0]
    P_charge_discharge_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(P_charge_discharge), orient='index').loc[:,0]
    E_SOC_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(E_SOC_t), orient='index').loc[:,0]    
    P_ptg_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(P_ptg_t), orient='index').loc[:,0]        
    m_H2_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(m_H2_t), orient='index').loc[:,0]    
    LoS_H2_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(LoS_H2_t), orient='index').loc[:,0]    
    m_H2_offtake_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(m_H2_offtake_t), orient='index').loc[:,0]
    m_H2_to_NH3_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(m_H2_to_NH3_t), orient='index').loc[:,0]
    P_HB_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(P_HB_t), orient='index').loc[:,0]
    P_ASU_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(P_ASU_t), orient='index').loc[:,0]
    m_NH3_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(m_NH3_t), orient='index').loc[:,0]
    LoS_NH3_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(LoS_NH3_t), orient='index').loc[:,0]
    m_NH3_offtake_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(m_NH3_offtake_t), orient='index').loc[:,0]
    Q_ts_df = pd.DataFrame.from_dict(sol.get_value_dict(Q_t), orient='index').loc[:,0]


    #make a time series like P_HPP with a constant penalty 
    #penalty_2 = sol.get_value(penalty)
    #penalty_ts = np.ones(N_t) * (penalty_2/N_t)
    penalty_ts_df = pd.Series(0, index = P_HPP_ts_df.index)
    mdl.end()
    

    # Cplex sometimes returns missing values :O
    P_HPP_ts = P_HPP_ts_df.reindex(time,fill_value=0).values
    P_curtailment_ts = P_curtailment_ts_df.reindex(time,fill_value=0).values
    P_charge_discharge_ts = P_charge_discharge_ts_df.reindex(time,fill_value=0).values
    E_SOC_ts = E_SOC_ts_df.reindex(SOCtime,fill_value=0).values
    P_ptg_ts = P_ptg_ts_df.reindex(time,fill_value=0).values
    m_H2_ts = m_H2_ts_df.reindex(time,fill_value=0).values
    LoS_H2_ts = LoS_H2_ts_df.reindex(time,fill_value=0).values
    m_H2_offtake_ts = m_H2_offtake_ts_df.reindex(time,fill_value=0).values
    m_H2_to_NH3_ts = m_H2_to_NH3_ts_df.reindex(time, fill_value = 0).values
    P_HB_ts = P_HB_ts_df.reindex(time,fill_value=0).values
    P_ASU_ts = P_ASU_ts_df.reindex(time,fill_value=0).values
    m_NH3_ts = m_NH3_ts_df.reindex(time,fill_value=0).values
    LoS_NH3_ts = LoS_NH3_ts_df.reindex(time,fill_value=0).values
    m_NH3_offtake_ts = m_NH3_offtake_ts_df.reindex(time,fill_value=0).values
    #Q_ts = (46.2)*(0.017*3.6e6)*m_NH3_ts
    Q_ts = Q_ts_df.reindex(time,fill_value=0).values
    penalty_ts = penalty_ts_df.reindex(time, fill_value = 0).values 

    if len(P_HPP_ts_df) < len(wind_ts):
        #print('recomputing p_hpp')
        P_HPP_ts = wind_ts.values + solar_ts.values +\
            - P_curtailment_ts + P_charge_discharge_ts - P_ptg_ts
    P_ptg_SB_ts = np.zeros_like(P_ptg_ts)
    for t in range(N_t):
        if abs(P_ptg_ts[t] - min_power_standby*ptg_MW) < 1e-6 :
           P_ptg_SB_ts[t] = min_power_standby*ptg_MW
           P_ptg_ts[t] = 0
           m_H2_ts[t] = 0
    
    return P_HPP_ts, P_curtailment_ts, P_charge_discharge_ts, P_ptg_ts, P_ptg_SB_ts, E_SOC_ts, m_H2_ts, m_H2_offtake_ts, m_H2_to_NH3_ts, LoS_H2_ts, penalty_ts, P_HB_ts, P_ASU_ts, m_NH3_ts, LoS_NH3_ts, m_NH3_offtake_ts, Q_ts


